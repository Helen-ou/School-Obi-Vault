**Trop Long ; Pas Lu** : J’ai conçu un challenge en Reverse Engineering, ma spécialité.

En cybersécurité, beaucoup progressent grâce à des plateformes comme RootMe ou HTB, qui proposent des challenges pour développer des compétences en autodidacte. Ces exercices sont formidables, mais pour moi, il y a quelque chose d’encore plus passionnant : _créer_ ces challenges.

Le Reverse Engineering étant mon domaine de prédilection, j’ai décidé de relever ce défi. Voici un aperçu des étapes et des défis rencontrés lors de cette aventure.

### La planification

Tout commence par des choix clés :

1. **Le langage de programmation** : J’ai choisi le C, car il est très proche du code assembleur. Cela permet de manipuler facilement le code tout en restant au plus près de la mécanique de la machine.
2. **L’idée derrière le challenge** : Initialement, je voulais exploiter un concept lié à la compilation pour obtenir un mot de passe. Mais cette piste s’est avérée trop simple à déchiffrer. Avec l’aide de @Robin GRZYWACS, nous avons exploré une nouvelle idée : utiliser une génération de nombres aléatoires prédictible pour cacher et révéler un mot de passe.

### La phase de création

Cette étape est à la fois technique et itérative : on code, on teste, on reverse, puis on ajuste le tout pour atteindre l’objectif. L’enjeu est de trouver le juste équilibre entre complexité et apprentissage pour les challengers. Ce processus est de loin le plus long et complexe à compléter, mais une version "facile" du défi est déjà terminée (Je peux la transmettre aux intéressés)

### Conclusion

Créer ce challenge a été une expérience à la fois technique et créative, qui m’a permis d’explorer de nouvelles idées tout en consolidant mes compétences. Si vous êtes curieux ou souhaitez en discuter, je serai ravi d’avoir vos retours !